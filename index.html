<!DOCTYPE html>
<html>
    <head>
        <title>
            Risk of Rain 2 Language file Editor
        </title>
        <!-- Because google isn't indexing this? -->
        <meta name="google-site-verification" content="hL0dJA3sewTEknEYd0JyJeghiZFZpSU2U62uGFdwwqI" />
        <style>
            @font-face {
                font-family:"bombardier";
                /* Install or place BOMBARD_.woff in the same folder as this file to load the font locally */
                src: local('Bombardier'), url('BOMBARD_.woff') format('woff');
                src: url("https://api.allorigins.win/raw?url=https://candyfonts.com/wp-data/2019/08/07/72363/BOMBARD_.ttf") format("truetype");
            }

            p {
                margin: 0;
            }

            body {
                font-family: Bombardier;
                text-shadow: 1px 1px black;
                font-size: 1.2em;
                background-image: linear-gradient(170deg, #7d7c8f, #405060);
                background-attachment: fixed;
                color: white;
                padding-bottom: 200px;
            }

            header {
                margin-left: 25px;
                max-width: 70ch;
            }

            header p {
                margin-bottom: 1rem;
            }

            main {
                padding: 25px;
            }

            main > fieldset {
                margin-bottom: 10px;
            }

            .load {
                display: flex;
            }

            .load fieldset {
                display: flex;
                flex-direction: column;
                border-color: #aaa;
                max-width: 300px;
            }

            .load p,
            .doc {
                font-size: 0.8rem;
                font-family: sans-serif;
                text-shadow: none;
                margin-top: 5px;
            }

            .doc {
                max-width: 70ch;
            }

            fieldset.waiting .hide-before {
                display: none;
            }

            fieldset.ready .hide-after {
                display: none;
            }

            fieldset.waiting .fade-before {
                opacity: 0.5;
            }

            p.hide-after {
                font-weight: bold;
            }

            input[type=file] {
                font-size: 1rem;
            }

            ._pickup {
                margin: 5px 0 0 0;
            }

            .export {
                padding: 5px 10px;
                margin: 10px;
                font-size: 1rem;
            }

            .palette {
                padding: 5px;
                margin: 5px;
                border: 1px solid #999;
                background: #444;
                box-shadow: 2px 2px 8px #222;
            }

           .replacements {
                margin: 15px 0;
            }

            .replacements dd {
                display: flex;
                gap: 20px;
            }

            .replacements textarea {
                width: 100%;
                border: none;
                padding: 5px;
                background-color: #353535;
                color: #bbb;
                box-shadow: 2px 2px 8px #222;
            }

            .preview {
                padding: 12px;
                border: 1px solid #999;
                background: #444;
            }

            .lang-file {
                margin-top: 25px;
            }

            .lang-file[open] + .lang-file {
                margin-top: 100px;
            }

            details h2 {
                display: inline;
            }

            .pair .preview,
            .pair .edit {
                box-shadow: 2px 2px 8px #222;
                margin-left: 40px;
            }

            .pair {
                margin-bottom: 10px;
            }

            .pair .key,
            .pair .base-name {
                display: inline-block;
            }

            .pair .base-name {
                font-style: italic;
                color: #ccc;
                margin-left: 1em;
            }

            .pair .base {
                margin-top: 10px;
                display: none;
            }

            body.show-base .pair.modified .base {
                display: flex;
            }

            .revert {
                width: 40px;
                display: flex;
            }

            .pair .base-preview {
                margin-left: 0;
            }

            .base-raw {
                font-family: sans-serif;
                font-size: 0.8rem;
                padding: 5px;
                background-color: #353535;
                color: #bbb;
            }

            .hidden {
                display: none;
            }

            .edit-value {
                width: 100%;
                border: none;
                padding: 5px;
                background-color: #353535;
                color: #bbb;
            }

            .modified .preview:not(.base-preview) {
                border-color: orange;
            }

            .hide-unmodified .pair:not(.modified) {
                display: none;
            }

            #TEST {
                margin-top: 40px;
            }

            .cIsHealth {
                color: #e58262;
            }

            .cIsDamage {
                color: #e5c962;
            }

            .cIsHealing {
                color: #9ce562;
            }

            .cIsUtility {
                color: #95cde5;
            }

            .cIsVoid {
                color: #DD7AC6;
            }

            .cStack {
                color: #8990a7;
            }

            .cWorldEvent {
                color: #ffc9f5;
            }

            .cArtifact {
                color: #8a5bc0;
            }

            .cUserSetting {
                color: #ffffd0;
            }

            .cDeath {
                color: #fe7c7c;
            }

            .cSub {
                color: #ccd3e0;
            }

            .cMono {
                color: #8990a7;
                letter-spacing: 5px;
            }

            .cShrine {
                color: #efeb1c;
            }

            .cEvent {
                color: #8394b3;
            }

            .palette span {
                margin-right: 5px;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>Risk of Rain 2 Language File Editor</h1>
            <p>Simplifies editing files like Items.txt and Equipment.txt for custom item names and descriptions.</p>
            <p>Tip: An easy way to use full descriptions for item tooltips without a mod is to open your files and then immediately save them with "<b>Only use description</b>" - that will replace the tooltip with the log book description.</p>
            <p><i>Note: This is a self-contained web app - nothing is uploaded to any server.</i></p>
        </header>
        <main>
            <a href="https://github.com/Xuerian/RoR2LanguageEditor" class="github-corner" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
            <fieldset class=load>
                <legend>
                    Load language files to edit
                </legend>
                <fieldset>
                    <legend>Base game language</legend>
                    <input type=file id=INPUT_FILE_BASE accept=.txt multiple>
                    <p>Located in <b><u>steamapps/common/Risk of Rain 2/Risk of Rain 2_Data/StreamingAssets/Language/en</u></b></p>
                    <p><b><u>Items.txt</u></b> and <b><u>Equipment.txt</u></b> are usually what you want to open</p>
                    <dl class=_pickup>
                        <dt>Tooltip text:</dt>
                        <dd><label><input type=radio name=_pickup value=normal> Keep</label></dd>
                        <dd><label><input type=radio name=_pickup value=copy> Copy description</label></dd>
                        <dd><label><input type=radio name=_pickup value=desc checked> Only use description</label></dd>
                    </dl>
                    <!-- <p>Can load merged files as well</p> -->
                </fieldset>
                <fieldset class="patch waiting">
                    <legend class="fade-before">Patch</legend>
                    <p class="doc hide-after">Base languages must be loaded before applying a patch</p>
                    <input class="hide-before" type=file id=INPUT_FILE_PATCH accept=".ror2lpatch.json,.ror2language.zip">
                    <p class="doc fade-before">A JSON file containing key/value pairs to change.</p>
                    <p class="doc fade-before">Saved in the zip file created with this tool - you may also load a ror2language.zip file containing a patch directly.</p>
                </fieldset>

                <fieldset class="merge waiting">
                    <legend class="fade-before">Merge language files</legend>
                    <p class="doc hide-after">Base languages must be loaded before merging</p>
                    <input class="hide-before" type=file id=INPUT_FILE_MERGE accept=".txt,.language" multiple>
                    <p class="doc fade-before">You can merge modified language files after opening the base language, like a patch.</p>
                    <dl class="_merge hide-before">
                        <dt>Overwrite:</dt>
                        <dd><label><input type=radio name=_merge value=all checked> All</label></dd>
                        <dd><label><input type=radio name=_merge value=default> Base values</label></dd>
                    </dl>
                </fieldset>
<!--
                <fieldset>
                    <legend>Replacements</legend>
                    <input type=file id=INPUT_FILE_REPLACEMENT accept=.r2lreplace.json multiple>
                </fieldset>
                <fieldset>
                    <legend>Convert Merged to Patches</legend>
                    <input type=file id=INPUT_FILE_REPLACEMENT accept=.txt multiple>
                    <p>Pre-existing modified language files can be loaded and parsed into patches automatically</p>
                </fieldset>
-->
            </fieldset>
            <button class=export>Save text files (As zip)</button>
            <p class=doc>Modified language .txt files will be in /en. Replace your game language files with these to use your modifications.</p>
            <p class=doc>.language files will be in /language, which are just renamed .txt files. These can be loaded without replacing your default files when using BepInEx. Place them in BepInEx\plugins\SOME_FOLDER\</p>
            <hr>
<!--
            <details class=replacements>
                <summary>Text replacements</summary>
                <template class=replacement>
                    <dt>Replace..... ...with</dt>
                    <dd>
                        <textarea class=replacement-search></textarea>
                        <textarea class=replacement-replace></textarea>
                    </dd>
                </template>
                <dl>

                </dl>
            </details>
-->
            <fieldset>
                <legend>
                    Filter
                </legend>
                <label>
                    By key
                    <input type=text id=INPUT_FILTER_KEY>
                </label>
                <label>
                    By value
                    <input type=text id=INPUT_FILTER_VALUE>
                </label>
                <label><input type=radio checked name=INPUT_FILTER_MODIFIED value="all"> Show all</label>
                <label><input type=radio name=INPUT_FILTER_MODIFIED value="modified"> Only modified</label>
                <label><input type=checkbox id=INPUT_SHOW_BASE checked> Show base value</label>
            </fieldset>
            <div class=palette>
                <span class=cIsHealth>cIsHealth</span>
                <span class=cIsDamage>cIsDamage</span>
                <span class=cIsHealing>cIsHealing</span>
                <span class=cIsUtility>cIsUtility</span>
                <span class=cIsVoid>cIsVoid</span>
                <span class=cStack>cStack</span>
                <span class=cWorldEvent>cWorldEvent</span>
                <span class=cArtifact>cArtifact</span>
                <span class=cUserSetting>cUserSetting</span>
                <span class=cDeath>cDeath</span>
                <span class=cSub>cSub</span>
                <span class=cMono>cMono</span>
                <span class=cShrine>cShrine</span>
                <span class=cEvent>cEvent</span>
            </div>
            <template class=file>
                <details class=lang-file open>
                    <summary>
                        <h2 class=file-name></h2>
                    </summary>
                    <section>

                    </section>
                </details>
            </template>
            <template class=file-pair>
                <div class=pair>
                    <div class=key></div><div class=base-name></div>
                    <div class=preview></div>
                    <div class=edit><input type=text class=edit-value></div>
                    <div class=base>
                        <div class=revert><button type=button><<</button></div>
                        <div>
                            <div class="preview base-preview"></div>
                            <div class=base-raw></div>
                        </div>
                    </div>
                </div>
            </template>
            <div id=OUTPUT>

            </div>
            <div id=TEST>
            </div>
        </main>
        <!-- FileSaver.js https://github.com/eligrey/FileSaver.js -->
        <script src="https://cdn.jsdelivr.net/g/filesaver.js"></script>
        <!-- JSZip https://stuk.github.io/jszip/ -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.3.0/jszip.min.js" integrity="sha256-J0jjrR5bYbE+saHyVcuvt2EIg5JAHN10VWyTHtVJV2E=" crossorigin="anonymous"></script>
        <!-- App script -->
        <script>
'use_strict';

const parseBadJSON = (bad, identifier) => {
    const fixed =
        bad
        // Unquoted strings, randomly
        .replace('strings:', '"strings":')
        // Why \B?
        .replace(/\\B/g, "B")
        // Only escape double quotes, because we only use double quotes
        .replace(/\\'/g, "'")
        // Can't end a list with a comma
        .replace(/,(\W+})/g, '$1')
        // Fat fingers
        .replace(/\.,$/gm, ',')
        // Invalid escapes
        .replace(/\\(\*|�)/g, '$1')
        // Un-escaped quotes
        .replace(/(?<=": ".+?)(?<!\\)"(?!,?\s*$)/gm, '\\"')
        // Comments
        .replace(/^[\t ]+\/\/.+$/gm, '')
    try {
        return JSON.parse(fixed)
    }
    catch (error) {
        const matches = error.message.match(/JSON.parse: (.+?) at line (\d+) column (\d+)/)
        if (matches) {
            const [match, message, str_line, str_column] = error.message.match(/JSON.parse: (.+?) at line (\d+) column (\d+)/)
            const line = Number(str_line)
            const column = Number(str_column)
            const lines = fixed.split('\n')
            console.error(`Error parsing [${identifier}]: ${message} at line ${line} column ${column}`)
            const context = [
                lines[line-2],
                lines[line-1],
                lines[line-1].replace(/[^\t ]/g, ' ').substr(0, column-1)+'^ message',
                lines[line]
            ]
            console.log('Context (Fixed):')
            console.log(context.join('\n'))
            console.log('Context (Raw):')
            console.log(bad.split('\n').slice(line-3, line+1).join('\n'))
            return {}
        }
        else {
            console.error(`Error parsing [${identifier}]`)
            throw error
        }
    }
}

const radioValue = (name) => {
    for (const e of document.querySelectorAll(`input[name=${name}]`)) {
        if (e.checked) {
            return e.value
        }
    }
}

const INPUT_FILE_BASE = document.getElementById('INPUT_FILE_BASE')
const INPUT_FILTER_KEY = document.getElementById('INPUT_FILTER_KEY')
const INPUT_FILTER_VALUE = document.getElementById('INPUT_FILTER_VALUE')
const INPUT_REPLACEMENTS = document.getElementById('INPUT_REPLACEMENTS')
const INPUT_FILE_PATCH = document.getElementById('INPUT_FILE_PATCH')
const INPUT_FILE_MERGE = document.getElementById('INPUT_FILE_MERGE')
const INPUT_SHOW_BASE = document.getElementById('INPUT_SHOW_BASE')
const OUTPUT = document.getElementById('OUTPUT')
let _PICKUP_VALUE = null

const tpl = name => {
    const e = document.querySelector(`template.${name}`)
    if (!e) {
        throw `template.${name} did not match any element`
    }
    return e.content.firstElementChild.cloneNode(true)
}

let strings_files = {}
let input_map = {}
let replacements = []

const parseMarkup = str => {
    return str
        .replace(/<(style|color)(?:=([^>]+))?>/gi, "<span data-tag='$1' data-value='$2'>")
        .replace(/<\/(style|color)>/gi, '</span>')
        .replace(/(\\n|\n)/g, '<br>')
}

const setPreview = (preview, value) => {
    preview.innerHTML = parseMarkup(value)
    preview.querySelectorAll('span[data-tag=color]').forEach(e => e.style.color = e.getAttribute('data-value'))
    preview.querySelectorAll('span[data-tag=style]').forEach(e => e.classList.add(e.getAttribute('data-value')))
}

let last_key_filter = ''
let last_value_filter = ''
const applyFilters = () => {
    if (INPUT_FILTER_KEY.value !== last_key_filter || INPUT_FILTER_VALUE.value !== last_value_filter) {
        last_key_filter = INPUT_FILTER_KEY.value.toLowerCase()
        last_value_filter = INPUT_FILTER_VALUE.value.toLowerCase()
        for (const file of Object.values(input_map)) {
            for (const [key, input] of Object.entries(file)) {
                let hidden = false
                if (last_key_filter && !key.toLowerCase().includes(last_key_filter)) {
                    hidden = true
                }
                if (!hidden && last_value_filter && !input.value.toLowerCase().includes(last_value_filter)) {
                    hidden = true
                }
                input.pair.classList.toggle('hidden', hidden)
            }
        }
    }
}

let nameMap = {}

const newEditorPair = (key, value) => {
    let baseName = null
    if (key.endsWith('_NAME')) {
        nameMap[key.split('_').slice(0, -1)] = value
        baseName = value
    }
    else {
        baseName = nameMap[key.split('_').slice(0, -1)]
    }
    const pair = tpl('file-pair')
    pair.querySelector('.key').textContent = key
    if (baseName) {
        pair.querySelector('.base-name').textContent = baseName
        pair.setAttribute('base-name', baseName)
    }
    const preview = pair.querySelector('.preview')
    setPreview(preview, value)
    const basePreview = pair.querySelector('.base-preview')
    const baseRaw = pair.querySelector('.base-raw')
    const input = pair.querySelector('input')
    input.value = value.replace(/\n/g, "\\n")
    input.initialValue = input.value
    input.key = key
    input.pair = pair
    input.addEventListener('input', () => {
        setPreview(preview, input.value)
        if (!input.baseInitialized) {
            input.baseInitialized = true
            setPreview(basePreview, input.initialValue)
            baseRaw.textContent = input.initialValue
            pair.querySelector('.revert').addEventListener('click', () => {
                input.value = input.initialValue
                input.dispatchEvent(new Event('input'))
            })
        }
        input.pair.classList.toggle('modified', input.value !== input.initialValue)
    })
    return [input, pair]
}

const renderFilteredFiles = () => {
    input_map = {}
    OUTPUT.innerHTML = ''
    for (const [file_name, file] of Object.entries(strings_files)) {
        input_map[file_name] = {}
        const file_block = tpl('file')
        file_block.querySelector('h2').textContent = file_name
        const section = file_block.querySelector('section')
        for (let [key, value] of Object.entries(file)) {
            if (key.endsWith('_PICKUP')) {
                if (_PICKUP_VALUE == 'copy') {
                    const desc = file[key.replace('_PICKUP', '_DESC')]
                    if (desc) {
                        value = desc
                    }
                }
                else if (_PICKUP_VALUE == 'desc') {
                    if (file[key.replace('_PICKUP', '_DESC')]) {
                        continue;
                    }
                }
            }
            const [input, pair] = newEditorPair(key, value)
            input.file = file_name
            input_map[file_name][key] = input
            section.append(pair)
        }
        OUTPUT.append(file_block)
    }
    for (const waiting of document.querySelectorAll('.waiting')) {
        waiting.classList.remove('waiting')
        waiting.classList.add('ready')
    }
    patchFiles_onChange.call(INPUT_FILE_PATCH)
}

const [test_input, test_pair] = newEditorPair('TEST_STRING', '')
test_input.setAttribute('placeholder', 'Test formatting here, it will not be saved or interfere with loaded files')
document.getElementById('TEST').append(test_pair)

function onFilesChange() {
    strings_files = {}
    let waiting = 0
    for (let i = 0; i < this.files.length; i++) {
        const file = this.files[i]
        const reader = new FileReader
        waiting++
        reader.onload = x => {
            waiting--
            strings_files[file.name] = parseBadJSON(x.target.result, file.name).strings
            if (waiting === 0) {
                _PICKUP_VALUE = radioValue('_pickup')
                renderFilteredFiles()
            }
        }
        reader.readAsText(file)
    }
}

INPUT_FILE_BASE.addEventListener('change', onFilesChange, false)
onFilesChange.call(INPUT_FILE_BASE)


const applyPatch = patch_json => {
    const patch = parseBadJSON(patch_json, 'Patch file')
    for (const [file_name, pairs] of Object.entries(patch)) {
        for (const [key, value] of Object.entries(pairs)) {
            if (input_map[file_name][key] ?? false) {
                input_map[file_name][key].value = value.replace(/\n/g, "\\n")
                input_map[file_name][key].dispatchEvent(new Event('input'))
                input_map[file_name][key].dispatchEvent(new Event('change'))
            }
            else {
                console.error(`PATCH ERROR: ${file_name}.${key} does not exist.`)
            }
        }
    }
    mergeFiles_onChange.call(INPUT_FILE_MERGE)
}

function patchFiles_onChange()
{
    const file = this.files[0] ?? null
    if (file) {
        if (file.name.endsWith('.ror2lpatch.json')) {
            const reader = new FileReader
            reader.onload = result => {
                applyPatch(result.target.result)
            }
            reader.readAsText(file)
        }
        else if (file.name.endsWith('.zip')) {
            JSZip.loadAsync(file).then(zip => {
                if (zip.files['custom.ror2lpatch.json']) {
                    zip.files['custom.ror2lpatch.json'].async('string').then(applyPatch)
                }
                else {
                    this.value = null
                    alert('Zip file did not contain a custom.ror2lpatch.json file')
                    throw "Invalid patch zip"
                }
            })
        }
        else {
            alert('Patching expects .ror2lpatch.json, or a zip with a custom.ror2lpatch.json file')
            throw "Invalid merge files"
        }
    }
    else {
        mergeFiles_onChange.call(INPUT_FILE_MERGE)
    }
}

// Called after base phase
INPUT_FILE_PATCH.addEventListener('change', patchFiles_onChange)


function mergeFiles_onChange()
{
    for (let i = 0; i < this.files.length; i++) {
        const file = this.files[i]
        if (!file.name.endsWith('txt') && !file.name.endsWith('.language') && !file.name.endsWith('.json')) {
            this.value = null
            alert('Merging expects .txt, .language, or .json files')
            throw "Invalid merge files"
        }
        const reader = new FileReader
        reader.onload = x => {
            const name = file.name.replace('.language', '.txt')
            const to_merge = parseBadJSON(x.target.result, file.name).strings
            if (to_merge) {
                for (const [key, value] of Object.entries(to_merge)) {
                    if (input_map[name] && input_map[name][key]) {
                        input_map[name][key].value = value.replace(/\n/g, "\\n")
                        input_map[name][key].dispatchEvent(new Event('input'))
                        input_map[name][key].dispatchEvent(new Event('change'))
                    }
                    else if (_PICKUP_VALUE === 'desc' && key.endsWith('_PICKUP')) {
                        console.info(`MERGE NOTICE: ${name}[${key}] not applied, "Tooltip text" is set to "Only use description" --`, value)
                    }
                    else {
                        console.warn(`MERGE ERROR: ${name}[${key}] does not exist. --`, value)
                    }
                }
            }
        }
        reader.readAsText(file)
    }
    applyFilters()
}

// Called after patching phase
INPUT_FILE_MERGE.addEventListener('change', mergeFiles_onChange)

function onFiltersChange() {
    applyFilters()
}

INPUT_FILTER_KEY.addEventListener('input', onFiltersChange, false)
INPUT_FILTER_VALUE.addEventListener('input', onFiltersChange, false)


document.querySelector('button.export').addEventListener('click', () => {
    const zip = new JSZip;
    const folder_en = zip.folder('en')
    const folder_language = zip.folder('language')
    const output = {}
    const patch = {}

    for (const [file_name, inputs] of Object.entries(input_map)) {
        output[file_name] = {}
        for (const [key, input] of Object.entries(inputs)) {
            if (input.initialValue && input.value !== input.initialValue) {
                if (!patch[file_name]) {
                    patch[file_name] = {}
                }
                patch[file_name][key] = input.value
            }
            const value = input.value.replace(/\\n/g, "\n")
            if (_PICKUP_VALUE === 'desc' && key.endsWith('_DESC') && strings_files[file_name][key.replace('_DESC', '_PICKUP')]) {
                output[file_name][key.replace('_DESC', '_PICKUP')] = value
            }
            output[file_name][key] = value
        }
        const str = JSON.stringify({strings: output[file_name]}, null, "\t")
        folder_en.file(file_name, str)
        folder_language.file(file_name.replace(/\.txt$/, '.language'), str)
    }

    if (Object.keys(patch)) {
        zip.file('custom.ror2lpatch.json', JSON.stringify(patch, null, "\t"))
    }

    zip.generateAsync({type:"blob"})
        .then(content => saveAs(content, 'custom.ror2language.zip'))
})


function modifiedFilter_onChange()
{
    document.body.classList.toggle('hide-unmodified', radioValue('INPUT_FILTER_MODIFIED') === 'modified')
}

for (const radio of document.querySelectorAll('input[name="INPUT_FILTER_MODIFIED"]')) {
    radio.addEventListener('change', modifiedFilter_onChange)
}
modifiedFilter_onChange()


function showBase_onChange()
{
    document.body.classList.toggle('show-base', this.checked)
}
INPUT_SHOW_BASE.addEventListener('change', showBase_onChange)
showBase_onChange.call(INPUT_SHOW_BASE)


        </script>
    </body>
</html>
